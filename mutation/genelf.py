# Copyright 2023 Flavien Solt, ETH Zurich.
# Licensed under the General Public License, Version 3.0, see LICENSE for details.
# SPDX-License-Identifier: GPL-3.0-only

# This module generates ELF files from a program generated by Cascade.

import os
import tempfile
import subprocess
from collections import defaultdict

from common.params.runparams import DO_ASSERT, PATH_TO_TMP
from common.bytestoelf import gen_elf
from mutation.finalblock import finalblock_spike_resolution, get_finalblock_max_size, finalblock


# From a fuzzerstate, generates an ELF, may it be for spike resolution or for RTL simulation
# Also integrates the final block.
# @param instr_objs an iterable (one per basic block) of iterables of CFInstructions or placeholders
# @param test_identifier typically the random seed, mem size, design name, max number of bbs
# @return the generated elf path
def gen_elf_from_bbs(fuzzerstate, is_spike_resolution, prefixname: str,
                     test_identifier: str, start_addr: int):
    if DO_ASSERT:
        assert len(fuzzerstate.instr_objs_seq) == len(fuzzerstate.bb_start_addr_seq)

    # ------------------------------------------------------------------
    # 1.  Collect every byte that belongs to the test-case image
    # ------------------------------------------------------------------
    addr_instrs = defaultdict(bytes)          # addr -> single byte

    # 1a.  ordinary basic blocks
    for bb_start_addr, bb_instrs in zip(fuzzerstate.bb_start_addr_seq,
                                        fuzzerstate.instr_objs_seq):
        for instr_id_in_bb, instr_obj in enumerate(bb_instrs):
            curr_bytecode = instr_obj.gen_bytecode_int(
                is_spike_resolution=is_spike_resolution).to_bytes(4, 'little')
            for curr_byte_id, curr_byte in enumerate(curr_bytecode):
                curr_addr = bb_start_addr + 4 * instr_id_in_bb + curr_byte_id
                if DO_ASSERT:
                    assert curr_addr not in addr_instrs, \
                        f"Trying to write twice to the same address: {hex(curr_addr)}"
                addr_instrs[curr_addr] = curr_byte

    # 1b.  context-save block
    for instr_id_in_bb, instr_obj in enumerate(fuzzerstate.ctxsv_bb):
        if instr_obj is None:
            raise ValueError(f"instrobj is None for ctxsv_bb at index {instr_id_in_bb}")
        curr_bytecode = instr_obj.gen_bytecode_int(
            is_spike_resolution=is_spike_resolution).to_bytes(4, 'little')
        for curr_byte_id, curr_byte in enumerate(curr_bytecode):
            curr_addr = fuzzerstate.ctxsv_bb_base_addr + 4 * instr_id_in_bb + curr_byte_id
            if DO_ASSERT:
                assert curr_addr not in addr_instrs, \
                    f"Trying to write twice to the same address: {hex(curr_addr)}"
            addr_instrs[curr_addr] = curr_byte

    # 1c.  initial register data (double-words)
    for reg_data_id, reg_data_doubleword in enumerate(fuzzerstate.initial_reg_data_content):
        curr_bytecode = reg_data_doubleword.to_bytes(8, 'little')
        for curr_byte_id, curr_byte in enumerate(curr_bytecode):
            curr_addr = fuzzerstate.initial_reg_data_addr + 8 * reg_data_id + curr_byte_id
            if DO_ASSERT:
                assert curr_addr not in addr_instrs, \
                    f"Trying to write twice to the same address: {hex(curr_addr)}"
            addr_instrs[curr_addr] = curr_byte

    # 1d.  final basic block
    final_block = (finalblock_spike_resolution() if is_spike_resolution
                   else fuzzerstate.final_bb)
    for instr_id_in_bb, instr_obj in enumerate(final_block):
        curr_bytecode = instr_obj.gen_bytecode_int(
            is_spike_resolution=is_spike_resolution).to_bytes(4, 'little')
        for curr_byte_id, curr_byte in enumerate(curr_bytecode):
            curr_addr = fuzzerstate.final_bb_base_addr + 4 * instr_id_in_bb + curr_byte_id
            if DO_ASSERT:
                assert curr_addr not in addr_instrs, \
                    f"Trying to write twice to the same address: {hex(curr_addr)}"
            addr_instrs[curr_addr] = curr_byte

    # 1e.  random data block
    for word_id, word_content in enumerate(fuzzerstate.random_block_content4by4bytes):
        curr_bytecode = word_content.to_bytes(4, 'little')
        for curr_byte_id, curr_byte in enumerate(curr_bytecode):
            curr_addr = fuzzerstate.random_data_block_start_addr + 4 * word_id + curr_byte_id
            if DO_ASSERT:
                assert curr_addr not in addr_instrs, \
                    f"Trying to write twice to the same address: {hex(curr_addr)}"
            addr_instrs[curr_addr] = curr_byte

    # ------------------------------------------------------------------
    # 2.  Place HTIF symbols *inside* the already allocated memory
    # ------------------------------------------------------------------
    # Pick an address that is guaranteed to be free and aligned:
    # immediately after the final basic block but before the random block.
    # We align it to 8 bytes and keep 16 bytes free.
    HTIF_SIZE      = 16
    HTIF_ADDR      = (fuzzerstate.final_bb_base_addr +
                      get_finalblock_max_size() * 4)  # end of final block
    HTIF_ADDR      = (HTIF_ADDR + 7) & ~7              # 8-byte align

    # make sure we do not collide with anything already allocated
    assert HTIF_ADDR + HTIF_SIZE <= fuzzerstate.random_data_block_start_addr, \
        "HTIF overlaps random-data block"
    for off in range(HTIF_SIZE):
        assert (HTIF_ADDR + off) not in addr_instrs, \
            f"HTIF collision at {hex(HTIF_ADDR + off)}"
        addr_instrs[HTIF_ADDR + off] = 0        # zero-initialise

    # Remember the address so basicblock.py can emit the correct store
    fuzzerstate.tohost_addr   = HTIF_ADDR
    fuzzerstate.fromhost_addr = HTIF_ADDR + 8

    # ------------------------------------------------------------------
    # 3.  Build contiguous byte array and write ELF
    # ------------------------------------------------------------------
    curr_bytearray = bytearray(fuzzerstate.memsize)  # zero filled
    for curr_addr, curr_byte in addr_instrs.items():
        curr_bytearray[curr_addr] = curr_byte
    payload_bytes = bytes(curr_bytearray)

    elfpath = os.path.join(PATH_TO_TMP, f"{prefixname}{test_identifier}.elf")

    # one-shot ELF creation â€“ symbols are now inside the image
    gen_elf(payload_bytes,
            start_addr=fuzzerstate.bb_start_addr_seq[0],
            section_addr=start_addr,
            destination_path=elfpath,
            is_64bit=fuzzerstate.is_design_64bit)
    return elfpath
